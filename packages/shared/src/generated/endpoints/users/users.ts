/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetDashboard200,
  GetUsersParams,
  HTTPValidationError,
  PostResetPassword200,
  PostResetPasswordParams,
  User,
  UserAdminCreate,
  UserAdminUpdate,
  UserListResponse,
  UserUpdate
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get current user information.

Returns the profile information of the authenticated user.
 * @summary Get Current User
 */
export const getMe = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/me`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMeQueryKey = () => {
    return [`http://localhost:8000/api/v1/users/me`] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


/**
 * @summary Get Current User
 */

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update current user information.

Allows users to update their own profile information.
 * @summary Update Current User
 */
export const putMe = (
    userUpdate: UserUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      options);
    }
  


export const getPutMeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMe>>, TError,{data: UserUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putMe>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['putMe'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putMe>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  putMe(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutMeMutationResult = NonNullable<Awaited<ReturnType<typeof putMe>>>
    export type PutMeMutationBody = UserUpdate
    export type PutMeMutationError = HTTPValidationError

    /**
 * @summary Update Current User
 */
export const usePutMe = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putMe>>, TError,{data: UserUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putMe>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getPutMeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get paginated list of users with optional filtering.

Requires admin privileges (MLGOO-DILG role).
 * @summary Get Users
 */
export const getUsers = (
    params?: GetUsersParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<UserListResponse>(
      {url: `http://localhost:8000/api/v1/users/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    return [`http://localhost:8000/api/v1/users/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = HTTPValidationError>(params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = HTTPValidationError


/**
 * @summary Get Users
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = HTTPValidationError>(
 params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new user.

Requires admin privileges (MLGOO-DILG role).
 * @summary Create User
 */
export const postUsers = (
    userAdminCreate: UserAdminCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userAdminCreate, signal
    },
      options);
    }
  


export const getPostUsersMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UserAdminCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UserAdminCreate}, TContext> => {

const mutationKey = ['postUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsers>>, {data: UserAdminCreate}> = (props) => {
          const {data} = props ?? {};

          return  postUsers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postUsers>>>
    export type PostUsersMutationBody = UserAdminCreate
    export type PostUsersMutationError = HTTPValidationError

    /**
 * @summary Create User
 */
export const usePostUsers = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UserAdminCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postUsers>>,
        TError,
        {data: UserAdminCreate},
        TContext
      > => {

      const mutationOptions = getPostUsersMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get user by ID.

Requires admin privileges (MLGOO-DILG role).
 * @summary Get User
 */
export const get${userId} = (
    userId: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserIdQueryKey = (userId: string,) => {
    return [`http://localhost:8000/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserIdQueryOptions = <TData = Awaited<ReturnType<typeof get${userId}>>, TError = HTTPValidationError>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get${userId}>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get${userId}>>> = ({ signal }) => get${userId}(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof get${userId}>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof get${userId}>>>
export type GetUserIdQueryError = HTTPValidationError


/**
 * @summary Get User
 */

export function useGetUserId<TData = Awaited<ReturnType<typeof get${userId}>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get${userId}>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update user by ID.

Requires admin privileges (MLGOO-DILG role).
 * @summary Update User
 */
export const put${userId} = (
    userId: string,
    userAdminUpdate: UserAdminUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userAdminUpdate
    },
      options);
    }
  


export const getPutUserIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof put${userId}>>, TError,{userId: string;data: UserAdminUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof put${userId}>>, TError,{userId: string;data: UserAdminUpdate}, TContext> => {

const mutationKey = ['putUserId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof put${userId}>>, {userId: string;data: UserAdminUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  put${userId}(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof put${userId}>>>
    export type PutUserIdMutationBody = UserAdminUpdate
    export type PutUserIdMutationError = HTTPValidationError

    /**
 * @summary Update User
 */
export const usePutUserId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof put${userId}>>, TError,{userId: string;data: UserAdminUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof put${userId}>>,
        TError,
        {userId: string;data: UserAdminUpdate},
        TContext
      > => {

      const mutationOptions = getPutUserIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Deactivate user by ID (soft delete).

Requires admin privileges (MLGOO-DILG role).
 * @summary Deactivate User
 */
export const delete${userId} = (
    userId: string,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/${userId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUserIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof delete${userId}>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof delete${userId}>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUserId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof delete${userId}>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  delete${userId}(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof delete${userId}>>>
    
    export type DeleteUserIdMutationError = HTTPValidationError

    /**
 * @summary Deactivate User
 */
export const useDeleteUserId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof delete${userId}>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof delete${userId}>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Activate user by ID.

Requires admin privileges (MLGOO-DILG role).
 * @summary Activate User
 */
export const postActivate = (
    userId: string,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<User>(
      {url: `http://localhost:8000/api/v1/users/${userId}/activate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostActivateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postActivate>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postActivate>>, TError,{userId: string}, TContext> => {

const mutationKey = ['postActivate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postActivate>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  postActivate(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostActivateMutationResult = NonNullable<Awaited<ReturnType<typeof postActivate>>>
    
    export type PostActivateMutationError = HTTPValidationError

    /**
 * @summary Activate User
 */
export const usePostActivate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postActivate>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postActivate>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getPostActivateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Reset user password.

Requires admin privileges (MLGOO-DILG role).
Sets must_change_password to True.
 * @summary Reset User Password
 */
export const postResetPassword = (
    userId: string,
    params: PostResetPasswordParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostResetPassword200>(
      {url: `http://localhost:8000/api/v1/users/${userId}/reset-password`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getPostResetPasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{userId: string;params: PostResetPasswordParams}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{userId: string;params: PostResetPasswordParams}, TContext> => {

const mutationKey = ['postResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postResetPassword>>, {userId: string;params: PostResetPasswordParams}> = (props) => {
          const {userId,params} = props ?? {};

          return  postResetPassword(userId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postResetPassword>>>
    
    export type PostResetPasswordMutationError = HTTPValidationError

    /**
 * @summary Reset User Password
 */
export const usePostResetPassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postResetPassword>>, TError,{userId: string;params: PostResetPasswordParams}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postResetPassword>>,
        TError,
        {userId: string;params: PostResetPasswordParams},
        TContext
      > => {

      const mutationOptions = getPostResetPasswordMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get user statistics for admin dashboard.

Requires admin privileges (MLGOO-DILG role).
 * @summary Get User Stats
 */
export const getDashboard = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetDashboard200>(
      {url: `http://localhost:8000/api/v1/users/stats/dashboard`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDashboardQueryKey = () => {
    return [`http://localhost:8000/api/v1/users/stats/dashboard`] as const;
    }

    
export const getGetDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getDashboard>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboard>>> = ({ signal }) => getDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDashboard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getDashboard>>>
export type GetDashboardQueryError = unknown


/**
 * @summary Get User Stats
 */

export function useGetDashboard<TData = Awaited<ReturnType<typeof getDashboard>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetDashboardQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



