/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssessmentDashboardResponse,
  AssessmentResponse,
  AssessmentResponseCreate,
  AssessmentResponseUpdate,
  AssessmentSubmissionValidation,
  DeleteAssessmentsMovsMovId200,
  GetAssessmentsList200Item,
  GetAssessmentsListParams,
  GetAssessmentsMyAssessment200,
  HTTPValidationError,
  MOVCreate,
  Mov,
  PostAssessmentsIdGenerateInsights202
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get dashboard data for the logged-in BLGU user's assessment.

Returns dashboard-specific data optimized for overview and progress tracking:
- Progress statistics (completed/total indicators)
- Governance area progress summaries
- Performance metrics (responses requiring rework, with feedback, with MOVs)
- Recent feedback summaries
- Assessment status and metadata

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get Assessment Dashboard
 */
export const getAssessmentsDashboard = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDashboardResponse>(
      {url: `http://localhost:8000/api/v1/assessments/dashboard`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsDashboardQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/dashboard`] as const;
    }

    
export const getGetAssessmentsDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsDashboard>>> = ({ signal }) => getAssessmentsDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsDashboard>>>
export type GetAssessmentsDashboardQueryError = unknown


/**
 * @summary Get Assessment Dashboard
 */

export function useGetAssessmentsDashboard<TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsDashboardQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get the complete assessment data for the logged-in BLGU user.

Returns the full assessment data including:
- Assessment status and metadata
- All governance areas with their indicators
- Form schemas for each indicator
- Existing response data for each indicator
- MOVs (Means of Verification) for each response
- Feedback comments from assessors

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get My Assessment
 */
export const getAssessmentsMyAssessment = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAssessmentsMyAssessment200>(
      {url: `http://localhost:8000/api/v1/assessments/my-assessment`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsMyAssessmentQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/my-assessment`] as const;
    }

    
export const getGetAssessmentsMyAssessmentQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsMyAssessmentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>> = ({ signal }) => getAssessmentsMyAssessment(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsMyAssessmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>>
export type GetAssessmentsMyAssessmentQueryError = unknown


/**
 * @summary Get My Assessment
 */

export function useGetAssessmentsMyAssessment<TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsMyAssessmentQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a specific assessment response by ID.

Returns the assessment response with all related data including:
- Response data (JSON)
- Completion status
- MOVs (Means of Verification)
- Feedback comments
 * @summary Get Assessment Response
 */
export const getAssessmentsResponses$ResponseId = (
    responseId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsResponsesResponseIdQueryKey = (responseId: number,) => {
    return [`http://localhost:8000/api/v1/assessments/responses/${responseId}`] as const;
    }

    
export const getGetAssessmentsResponsesResponseIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsResponsesResponseIdQueryKey(responseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>> = ({ signal }) => getAssessmentsResponses$ResponseId(responseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(responseId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsResponsesResponseIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>>
export type GetAssessmentsResponsesResponseIdQueryError = HTTPValidationError


/**
 * @summary Get Assessment Response
 */

export function useGetAssessmentsResponsesResponseId<TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(
 responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsResponsesResponseIdQueryOptions(responseId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an assessment response with validation.

Updates the response data and validates it against the indicator's form schema.
The response data must conform to the JSON schema defined in the indicator's
form_schema field.

Business Rules:
- Only responses belonging to the current user's assessment can be updated
- Response data is validated against the indicator's form schema
- Completion status is automatically updated based on response data
 * @summary Update Assessment Response
 */
export const putAssessmentsResponses$ResponseId = (
    responseId: number,
    assessmentResponseUpdate: AssessmentResponseUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseUpdate
    },
      options);
    }
  


export const getPutAssessmentsResponsesResponseIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext> => {

const mutationKey = ['putAssessmentsResponsesResponseId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, {responseId: number;data: AssessmentResponseUpdate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  putAssessmentsResponses$ResponseId(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAssessmentsResponsesResponseIdMutationResult = NonNullable<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>>
    export type PutAssessmentsResponsesResponseIdMutationBody = AssessmentResponseUpdate
    export type PutAssessmentsResponsesResponseIdMutationError = HTTPValidationError

    /**
 * @summary Update Assessment Response
 */
export const usePutAssessmentsResponsesResponseId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>,
        TError,
        {responseId: number;data: AssessmentResponseUpdate},
        TContext
      > => {

      const mutationOptions = getPutAssessmentsResponsesResponseIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Create a new assessment response.

Creates a new response for a specific indicator in the user's assessment.
The response data is validated against the indicator's form schema.
 * @summary Create Assessment Response
 */
export const postAssessmentsResponses = (
    assessmentResponseCreate: AssessmentResponseCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponses'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses>>, {data: AssessmentResponseCreate}> = (props) => {
          const {data} = props ?? {};

          return  postAssessmentsResponses(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses>>>
    export type PostAssessmentsResponsesMutationBody = AssessmentResponseCreate
    export type PostAssessmentsResponsesMutationError = HTTPValidationError

    /**
 * @summary Create Assessment Response
 */
export const usePostAssessmentsResponses = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses>>,
        TError,
        {data: AssessmentResponseCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Submit the assessment for review.

Runs a preliminary compliance check before submission:
- Ensures no "YES" answers exist without corresponding MOVs (Means of Verification)
- Updates assessment status to "Submitted for Review"
- Sets submission timestamp

Returns validation results with any errors or warnings.
 * @summary Submit Assessment
 */
export const postAssessmentsSubmit = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentSubmissionValidation>(
      {url: `http://localhost:8000/api/v1/assessments/submit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsSubmitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext> => {

const mutationKey = ['postAssessmentsSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsSubmit>>, void> = () => {
          

          return  postAssessmentsSubmit(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsSubmit>>>
    
    export type PostAssessmentsSubmitMutationError = unknown

    /**
 * @summary Submit Assessment
 */
export const usePostAssessmentsSubmit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsSubmit>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAssessmentsSubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Submit a specific assessment for review by ID.

Validates that the assessment belongs to the current BLGU user, runs the
preliminary compliance check (no "YES" answers without MOVs), and updates
the status to "Submitted for Review" if valid.
 * @summary Submit Assessment By Id
 */
export const postAssessments$AssessmentIdSubmit = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentSubmissionValidation>(
      {url: `http://localhost:8000/api/v1/assessments/${assessmentId}/submit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsAssessmentIdSubmitMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessmentsAssessmentIdSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessments$AssessmentIdSubmit(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsAssessmentIdSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>>
    
    export type PostAssessmentsAssessmentIdSubmitMutationError = HTTPValidationError

    /**
 * @summary Submit Assessment By Id
 */
export const usePostAssessmentsAssessmentIdSubmit = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$AssessmentIdSubmit>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsAssessmentIdSubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Upload a MOV (Means of Verification) file for an assessment response.

Creates a record of the uploaded file in the database. The actual file
upload to Supabase Storage should be handled by the frontend before
calling this endpoint.
 * @summary Upload Mov
 */
export const postAssessmentsResponses$ResponseIdMovs = (
    responseId: number,
    mOVCreate: MOVCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<Mov>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}/movs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mOVCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesResponseIdMovsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponsesResponseIdMovs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, {responseId: number;data: MOVCreate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessmentsResponses$ResponseIdMovs(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesResponseIdMovsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>>
    export type PostAssessmentsResponsesResponseIdMovsMutationBody = MOVCreate
    export type PostAssessmentsResponsesResponseIdMovsMutationError = HTTPValidationError

    /**
 * @summary Upload Mov
 */
export const usePostAssessmentsResponsesResponseIdMovs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>,
        TError,
        {responseId: number;data: MOVCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesResponseIdMovsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete a MOV (Means of Verification) file.

Removes the MOV record from the database. The actual file deletion
from Supabase Storage should be handled separately.
 * @summary Delete Mov
 */
export const deleteAssessmentsMovs$MovId = (
    movId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<DeleteAssessmentsMovsMovId200>(
      {url: `http://localhost:8000/api/v1/assessments/movs/${movId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssessmentsMovsMovIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext> => {

const mutationKey = ['deleteAssessmentsMovsMovId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, {movId: number}> = (props) => {
          const {movId} = props ?? {};

          return  deleteAssessmentsMovs$MovId(movId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessmentsMovsMovIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>>
    
    export type DeleteAssessmentsMovsMovIdMutationError = HTTPValidationError

    /**
 * @summary Delete Mov
 */
export const useDeleteAssessmentsMovsMovId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>,
        TError,
        {movId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssessmentsMovsMovIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get all validated assessments with compliance status.

Returns a list of all validated assessments with their compliance status,
area results, and barangay information. Used for MLGOO reports dashboard.

Args:
    status: Filter by assessment status (defaults to VALIDATED)
    db: Database session
    current_user: Current admin/MLGOO user

Returns:
    List of assessment dictionaries with compliance data
 * @summary Get All Validated Assessments
 */
export const getAssessmentsList = (
    params?: GetAssessmentsListParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAssessmentsList200Item[]>(
      {url: `http://localhost:8000/api/v1/assessments/list`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAssessmentsListQueryKey = (params?: GetAssessmentsListParams,) => {
    return [`http://localhost:8000/api/v1/assessments/list`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAssessmentsListQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsList>>, TError = HTTPValidationError>(params?: GetAssessmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsList>>> = ({ signal }) => getAssessmentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsList>>>
export type GetAssessmentsListQueryError = HTTPValidationError


/**
 * @summary Get All Validated Assessments
 */

export function useGetAssessmentsList<TData = Awaited<ReturnType<typeof getAssessmentsList>>, TError = HTTPValidationError>(
 params?: GetAssessmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsList>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Generate AI-powered insights for a validated assessment.

This endpoint dispatches a background Celery task to generate AI insights
using the Gemini API. The task runs asynchronously and results are stored
in the ai_recommendations field.

**Business Rules:**
- Only works for assessments with VALIDATED status
- Returns 202 Accepted immediately (asynchronous processing)
- Task includes automatic retry logic (max 3 attempts with exponential backoff)
- Results are cached to avoid duplicate API calls

**Response:**
- Immediately returns 202 Accepted with task information
- Frontend should poll assessment endpoint to check for ai_recommendations field

Args:
    id: Assessment ID
    db: Database session
    current_user: Current authenticated user

Returns:
    dict: Task dispatch confirmation
 * @summary Generate Insights
 */
export const postAssessments$IdGenerateInsights = (
    id: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostAssessmentsIdGenerateInsights202>(
      {url: `http://localhost:8000/api/v1/assessments/${id}/generate-insights`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsIdGenerateInsightsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext> => {

const mutationKey = ['postAssessmentsIdGenerateInsights'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postAssessments$IdGenerateInsights(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsIdGenerateInsightsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>>
    
    export type PostAssessmentsIdGenerateInsightsMutationError = HTTPValidationError

    /**
 * @summary Generate Insights
 */
export const usePostAssessmentsIdGenerateInsights = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessments$IdGenerateInsights>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsIdGenerateInsightsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    