/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssessmentDashboardResponse,
  AssessmentResponse,
  AssessmentResponseCreate,
  AssessmentResponseUpdate,
  AssessmentSubmissionValidation,
  DeleteAssessmentsMovsMovId200,
  GetAssessmentsMyAssessment200,
  HTTPValidationError,
  MOVCreate,
  Mov
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get dashboard data for the logged-in BLGU user's assessment.

Returns dashboard-specific data optimized for overview and progress tracking:
- Progress statistics (completed/total indicators)
- Governance area progress summaries
- Performance metrics (responses requiring rework, with feedback, with MOVs)
- Recent feedback summaries
- Assessment status and metadata

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get Assessment Dashboard
 */
export const getAssessmentsDashboard = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDashboardResponse>(
      {url: `http://localhost:8000/api/v1/assessments/dashboard`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsDashboardQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/dashboard`] as const;
    }

    
export const getGetAssessmentsDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsDashboard>>> = ({ signal }) => getAssessmentsDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsDashboard>>>
export type GetAssessmentsDashboardQueryError = unknown


/**
 * @summary Get Assessment Dashboard
 */

export function useGetAssessmentsDashboard<TData = Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsDashboard>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsDashboardQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get the complete assessment data for the logged-in BLGU user.

Returns the full assessment data including:
- Assessment status and metadata
- All governance areas with their indicators
- Form schemas for each indicator
- Existing response data for each indicator
- MOVs (Means of Verification) for each response
- Feedback comments from assessors

This endpoint automatically creates an assessment if one doesn't exist
for the BLGU user.
 * @summary Get My Assessment
 */
export const getAssessmentsMyAssessment = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<GetAssessmentsMyAssessment200>(
      {url: `http://localhost:8000/api/v1/assessments/my-assessment`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsMyAssessmentQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessments/my-assessment`] as const;
    }

    
export const getGetAssessmentsMyAssessmentQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsMyAssessmentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>> = ({ signal }) => getAssessmentsMyAssessment(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsMyAssessmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>>
export type GetAssessmentsMyAssessmentQueryError = unknown


/**
 * @summary Get My Assessment
 */

export function useGetAssessmentsMyAssessment<TData = Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsMyAssessment>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsMyAssessmentQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a specific assessment response by ID.

Returns the assessment response with all related data including:
- Response data (JSON)
- Completion status
- MOVs (Means of Verification)
- Feedback comments
 * @summary Get Assessment Response
 */
export const getAssessmentsResponses$ResponseId = (
    responseId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessmentsResponsesResponseIdQueryKey = (responseId: number,) => {
    return [`http://localhost:8000/api/v1/assessments/responses/${responseId}`] as const;
    }

    
export const getGetAssessmentsResponsesResponseIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsResponsesResponseIdQueryKey(responseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>> = ({ signal }) => getAssessmentsResponses$ResponseId(responseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(responseId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessmentsResponsesResponseIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>>
export type GetAssessmentsResponsesResponseIdQueryError = HTTPValidationError


/**
 * @summary Get Assessment Response
 */

export function useGetAssessmentsResponsesResponseId<TData = Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError = HTTPValidationError>(
 responseId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessmentsResponses$ResponseId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessmentsResponsesResponseIdQueryOptions(responseId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an assessment response with validation.

Updates the response data and validates it against the indicator's form schema.
The response data must conform to the JSON schema defined in the indicator's
form_schema field.

Business Rules:
- Only responses belonging to the current user's assessment can be updated
- Response data is validated against the indicator's form schema
- Completion status is automatically updated based on response data
 * @summary Update Assessment Response
 */
export const putAssessmentsResponses$ResponseId = (
    responseId: number,
    assessmentResponseUpdate: AssessmentResponseUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseUpdate
    },
      options);
    }
  


export const getPutAssessmentsResponsesResponseIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext> => {

const mutationKey = ['putAssessmentsResponsesResponseId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, {responseId: number;data: AssessmentResponseUpdate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  putAssessmentsResponses$ResponseId(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutAssessmentsResponsesResponseIdMutationResult = NonNullable<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>>
    export type PutAssessmentsResponsesResponseIdMutationBody = AssessmentResponseUpdate
    export type PutAssessmentsResponsesResponseIdMutationError = HTTPValidationError

    /**
 * @summary Update Assessment Response
 */
export const usePutAssessmentsResponsesResponseId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>, TError,{responseId: number;data: AssessmentResponseUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putAssessmentsResponses$ResponseId>>,
        TError,
        {responseId: number;data: AssessmentResponseUpdate},
        TContext
      > => {

      const mutationOptions = getPutAssessmentsResponsesResponseIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Create a new assessment response.

Creates a new response for a specific indicator in the user's assessment.
The response data is validated against the indicator's form schema.
 * @summary Create Assessment Response
 */
export const postAssessmentsResponses = (
    assessmentResponseCreate: AssessmentResponseCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentResponse>(
      {url: `http://localhost:8000/api/v1/assessments/responses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentResponseCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponses'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses>>, {data: AssessmentResponseCreate}> = (props) => {
          const {data} = props ?? {};

          return  postAssessmentsResponses(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses>>>
    export type PostAssessmentsResponsesMutationBody = AssessmentResponseCreate
    export type PostAssessmentsResponsesMutationError = HTTPValidationError

    /**
 * @summary Create Assessment Response
 */
export const usePostAssessmentsResponses = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses>>, TError,{data: AssessmentResponseCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses>>,
        TError,
        {data: AssessmentResponseCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Submit the assessment for review.

Runs a preliminary compliance check before submission:
- Ensures no "YES" answers exist without corresponding MOVs (Means of Verification)
- Updates assessment status to "Submitted for Review"
- Sets submission timestamp

Returns validation results with any errors or warnings.
 * @summary Submit Assessment
 */
export const postAssessmentsSubmit = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentSubmissionValidation>(
      {url: `http://localhost:8000/api/v1/assessments/submit`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessmentsSubmitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext> => {

const mutationKey = ['postAssessmentsSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsSubmit>>, void> = () => {
          

          return  postAssessmentsSubmit(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsSubmit>>>
    
    export type PostAssessmentsSubmitMutationError = unknown

    /**
 * @summary Submit Assessment
 */
export const usePostAssessmentsSubmit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsSubmit>>, TError,void, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsSubmit>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostAssessmentsSubmitMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Upload a MOV (Means of Verification) file for an assessment response.

Creates a record of the uploaded file in the database. The actual file
upload to Supabase Storage should be handled by the frontend before
calling this endpoint.
 * @summary Upload Mov
 */
export const postAssessmentsResponses$ResponseIdMovs = (
    responseId: number,
    mOVCreate: MOVCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<Mov>(
      {url: `http://localhost:8000/api/v1/assessments/responses/${responseId}/movs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mOVCreate, signal
    },
      options);
    }
  


export const getPostAssessmentsResponsesResponseIdMovsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext> => {

const mutationKey = ['postAssessmentsResponsesResponseIdMovs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, {responseId: number;data: MOVCreate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessmentsResponses$ResponseIdMovs(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessmentsResponsesResponseIdMovsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>>
    export type PostAssessmentsResponsesResponseIdMovsMutationBody = MOVCreate
    export type PostAssessmentsResponsesResponseIdMovsMutationError = HTTPValidationError

    /**
 * @summary Upload Mov
 */
export const usePostAssessmentsResponsesResponseIdMovs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessmentsResponses$ResponseIdMovs>>,
        TError,
        {responseId: number;data: MOVCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessmentsResponsesResponseIdMovsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Delete a MOV (Means of Verification) file.

Removes the MOV record from the database. The actual file deletion
from Supabase Storage should be handled separately.
 * @summary Delete Mov
 */
export const deleteAssessmentsMovs$MovId = (
    movId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<DeleteAssessmentsMovsMovId200>(
      {url: `http://localhost:8000/api/v1/assessments/movs/${movId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssessmentsMovsMovIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext> => {

const mutationKey = ['deleteAssessmentsMovsMovId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, {movId: number}> = (props) => {
          const {movId} = props ?? {};

          return  deleteAssessmentsMovs$MovId(movId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessmentsMovsMovIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>>
    
    export type DeleteAssessmentsMovsMovIdMutationError = HTTPValidationError

    /**
 * @summary Delete Mov
 */
export const useDeleteAssessmentsMovsMovId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>, TError,{movId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessmentsMovs$MovId>>,
        TError,
        {movId: number},
        TContext
      > => {

      const mutationOptions = getDeleteAssessmentsMovsMovIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    