/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AssessmentDetailsResponse,
  AssessorQueueItem,
  HTTPValidationError,
  MOVCreate,
  MOVUploadResponse,
  ValidationRequest,
  ValidationResponse
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get the assessor's secure submissions queue.

Returns a list of submissions filtered by the assessor's governance area.
 * @summary Get Assessor Queue
 */
export const getAssessorQueue = (
    
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessorQueueItem[]>(
      {url: `http://localhost:8000/api/v1/assessor/queue`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessorQueueQueryKey = () => {
    return [`http://localhost:8000/api/v1/assessor/queue`] as const;
    }

    
export const getGetAssessorQueueQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorQueue>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorQueueQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorQueue>>> = ({ signal }) => getAssessorQueue(requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorQueueQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorQueue>>>
export type GetAssessorQueueQueryError = unknown


/**
 * @summary Get Assessor Queue
 */

export function useGetAssessorQueue<TData = Awaited<ReturnType<typeof getAssessorQueue>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorQueue>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorQueueQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Validate an assessment response.

Accepts validation status (Pass/Fail/Conditional), public comment, and internal note.
Saves both comments to the feedback_comments table with appropriate flags.
 * @summary Validate Assessment Response
 */
export const postAssessorAssessmentResponses$ResponseIdValidate = (
    responseId: number,
    validationRequest: ValidationRequest,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<ValidationResponse>(
      {url: `http://localhost:8000/api/v1/assessor/assessment-responses/${responseId}/validate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: validationRequest, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentResponsesResponseIdValidateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext> => {

const mutationKey = ['postAssessorAssessmentResponsesResponseIdValidate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, {responseId: number;data: ValidationRequest}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessorAssessmentResponses$ResponseIdValidate(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentResponsesResponseIdValidateMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>>
    export type PostAssessorAssessmentResponsesResponseIdValidateMutationBody = ValidationRequest
    export type PostAssessorAssessmentResponsesResponseIdValidateMutationError = HTTPValidationError

    /**
 * @summary Validate Assessment Response
 */
export const usePostAssessorAssessmentResponsesResponseIdValidate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>, TError,{responseId: number;data: ValidationRequest}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdValidate>>,
        TError,
        {responseId: number;data: ValidationRequest},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentResponsesResponseIdValidateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Upload a MOV (Means of Verification) for an assessment response.

Allows assessors to upload MOVs for assessment responses they are reviewing.
The assessor must have permission to review responses in the same governance
area as the assessment response's indicator.

Note: The actual file upload to Supabase Storage should be handled by the
frontend before calling this endpoint.
 * @summary Upload Mov For Assessor
 */
export const postAssessorAssessmentResponses$ResponseIdMovs = (
    responseId: number,
    mOVCreate: MOVCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<MOVUploadResponse>(
      {url: `http://localhost:8000/api/v1/assessor/assessment-responses/${responseId}/movs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mOVCreate, signal
    },
      options);
    }
  


export const getPostAssessorAssessmentResponsesResponseIdMovsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext> => {

const mutationKey = ['postAssessorAssessmentResponsesResponseIdMovs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, {responseId: number;data: MOVCreate}> = (props) => {
          const {responseId,data} = props ?? {};

          return  postAssessorAssessmentResponses$ResponseIdMovs(responseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentResponsesResponseIdMovsMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>>
    export type PostAssessorAssessmentResponsesResponseIdMovsMutationBody = MOVCreate
    export type PostAssessorAssessmentResponsesResponseIdMovsMutationError = HTTPValidationError

    /**
 * @summary Upload Mov For Assessor
 */
export const usePostAssessorAssessmentResponsesResponseIdMovs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>, TError,{responseId: number;data: MOVCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessmentResponses$ResponseIdMovs>>,
        TError,
        {responseId: number;data: MOVCreate},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentResponsesResponseIdMovsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get detailed assessment data for assessor review.

Returns full assessment details including:
- Assessment metadata and status
- BLGU user information and barangay details
- All responses with indicators and technical notes
- MOVs (Means of Verification) for each response
- Feedback comments from assessors

The assessor must have permission to view assessments in their
governance area. Technical notes are included for each indicator
to provide guidance during the review process.
 * @summary Get Assessment Details
 */
export const getAssessorAssessments$AssessmentId = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<AssessmentDetailsResponse>(
      {url: `http://localhost:8000/api/v1/assessor/assessments/${assessmentId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssessorAssessmentsAssessmentIdQueryKey = (assessmentId: number,) => {
    return [`http://localhost:8000/api/v1/assessor/assessments/${assessmentId}`] as const;
    }

    
export const getGetAssessorAssessmentsAssessmentIdQueryOptions = <TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError = HTTPValidationError>(assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessorAssessmentsAssessmentIdQueryKey(assessmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>> = ({ signal }) => getAssessorAssessments$AssessmentId(assessmentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assessmentId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssessorAssessmentsAssessmentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>>
export type GetAssessorAssessmentsAssessmentIdQueryError = HTTPValidationError


/**
 * @summary Get Assessment Details
 */

export function useGetAssessorAssessmentsAssessmentId<TData = Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError = HTTPValidationError>(
 assessmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssessorAssessments$AssessmentId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssessorAssessmentsAssessmentIdQueryOptions(assessmentId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Send assessment back to BLGU user for rework.

Changes the assessment status to 'Needs Rework' and triggers a notification
to the BLGU user. This endpoint fails with a 403 error if the assessment's
rework_count is not 0 (meaning it has already been sent for rework).

The assessor must have permission to review assessments in their governance area.
 * @summary Send Assessment For Rework
 */
export const postAssessorAssessments$AssessmentIdRework = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `http://localhost:8000/api/v1/assessor/assessments/${assessmentId}/rework`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdReworkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdRework'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdRework(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdReworkMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>>
    
    export type PostAssessorAssessmentsAssessmentIdReworkMutationError = HTTPValidationError

    /**
 * @summary Send Assessment For Rework
 */
export const usePostAssessorAssessmentsAssessmentIdRework = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdRework>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdReworkMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Finalize assessment validation, permanently locking it.

Changes the assessment status to 'Validated', permanently locking the assessment
from further edits by either the BLGU or the Assessor. This action can only be
performed if all assessment responses have been reviewed (have a validation status).

The assessor must have permission to review assessments in their governance area.
 * @summary Finalize Assessment
 */
export const postAssessorAssessments$AssessmentIdFinalize = (
    assessmentId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<unknown>(
      {url: `http://localhost:8000/api/v1/assessor/assessments/${assessmentId}/finalize`, method: 'POST', signal
    },
      options);
    }
  


export const getPostAssessorAssessmentsAssessmentIdFinalizeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext> => {

const mutationKey = ['postAssessorAssessmentsAssessmentIdFinalize'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, {assessmentId: number}> = (props) => {
          const {assessmentId} = props ?? {};

          return  postAssessorAssessments$AssessmentIdFinalize(assessmentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAssessorAssessmentsAssessmentIdFinalizeMutationResult = NonNullable<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>>
    
    export type PostAssessorAssessmentsAssessmentIdFinalizeMutationError = HTTPValidationError

    /**
 * @summary Finalize Assessment
 */
export const usePostAssessorAssessmentsAssessmentIdFinalize = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>, TError,{assessmentId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postAssessorAssessments$AssessmentIdFinalize>>,
        TError,
        {assessmentId: number},
        TContext
      > => {

      const mutationOptions = getPostAssessorAssessmentsAssessmentIdFinalizeMutationOptions(options);

      return useMutation(mutationOptions );
    }
    