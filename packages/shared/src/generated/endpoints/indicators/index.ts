/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  FormSchemaInput,
  GetIndicatorsParams,
  HTTPValidationError,
  IndicatorCreate,
  IndicatorHistoryResponse,
  IndicatorResponse,
  IndicatorUpdate,
  PostIndicatorsValidateFormSchema200
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new indicator with version 1.

**Permissions**: MLGOO_DILG only

**Request Body**:
- name: Indicator name (min 3 characters)
- description: Optional description
- governance_area_id: ID of governance area
- parent_id: Optional parent indicator ID (for hierarchical structure)
- is_active: Active status (default: True)
- is_profiling_only: Profiling-only flag (default: False)
- is_auto_calculable: Auto-calculable Pass/Fail flag (default: False)
- form_schema: Optional form schema (JSON)
- calculation_schema: Optional calculation schema (JSON)
- remark_schema: Optional remark schema (JSON)
- technical_notes_text: Optional technical notes

**Returns**: Created indicator with version 1
 * @summary Create a new indicator
 */
export const postIndicators = (
    indicatorCreate: IndicatorCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext> => {

const mutationKey = ['postIndicators'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicators>>, {data: IndicatorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicators(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicators>>>
    export type PostIndicatorsMutationBody = IndicatorCreate
    export type PostIndicatorsMutationError = HTTPValidationError

    /**
 * @summary Create a new indicator
 */
export const usePostIndicators = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicators>>,
        TError,
        {data: IndicatorCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * List indicators with optional filtering.

**Permissions**: All authenticated users

**Query Parameters**:
- governance_area_id: Filter by governance area (optional)
- is_active: Filter by active status (optional)
- skip: Pagination offset (default: 0)
- limit: Max records (default: 100, max: 1000)

**Returns**: List of indicators matching filters
 * @summary List all indicators
 */
export const getIndicators = (
    params?: GetIndicatorsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIndicatorsQueryKey = (params?: GetIndicatorsParams,) => {
    return [`http://localhost:8000/api/v1/indicators/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators>>> = ({ signal }) => getIndicators(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators>>>
export type GetIndicatorsQueryError = HTTPValidationError


/**
 * @summary List all indicators
 */

export function useGetIndicators<TData = Awaited<ReturnType<typeof getIndicators>>, TError = HTTPValidationError>(
 params?: GetIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Validate a form schema without saving it.

**Permissions**: MLGOO_DILG only

**Request Body**:
- form_schema: FormSchema object with fields to validate

**Returns**:
- `{"valid": true}` if the schema is valid
- `{"valid": false, "errors": [...]}` if validation fails with detailed error messages

**Validation Checks**:
- Field IDs are unique
- No circular references in conditional logic
- Conditional MOV references point to existing fields
- Checkbox/Radio fields have at least one option
- Fields list is not empty

**Status Codes**:
- 200: Schema is valid
- 400: Schema is invalid (returns error details)
- 401: Unauthorized (not authenticated)
- 403: Forbidden (not MLGOO_DILG role)
 * @summary Validate a form schema
 */
export const postIndicatorsValidateFormSchema = (
    formSchemaInput: FormSchemaInput,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<PostIndicatorsValidateFormSchema200>(
      {url: `http://localhost:8000/api/v1/indicators/validate-form-schema`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: formSchemaInput, signal
    },
      options);
    }
  


export const getPostIndicatorsValidateFormSchemaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchemaInput}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchemaInput}, TContext> => {

const mutationKey = ['postIndicatorsValidateFormSchema'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, {data: FormSchemaInput}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsValidateFormSchema(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsValidateFormSchemaMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>>
    export type PostIndicatorsValidateFormSchemaMutationBody = FormSchemaInput
    export type PostIndicatorsValidateFormSchemaMutationError = HTTPValidationError

    /**
 * @summary Validate a form schema
 */
export const usePostIndicatorsValidateFormSchema = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>, TError,{data: FormSchemaInput}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsValidateFormSchema>>,
        TError,
        {data: FormSchemaInput},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsValidateFormSchemaMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get a specific indicator by ID.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: Indicator details including current version

**Raises**:
- 404: Indicator not found
 * @summary Get indicator by ID
 */
export const getIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorIdQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/${indicatorId}`] as const;
    }

    
export const getGetIndicatorsIndicatorIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorId>>> = ({ signal }) => getIndicators$IndicatorId(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorId>>>
export type GetIndicatorsIndicatorIdQueryError = HTTPValidationError


/**
 * @summary Get indicator by ID
 */

export function useGetIndicatorsIndicatorId<TData = Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an indicator.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to update

**Request Body**: All fields optional for partial updates
- name: Indicator name (min 3 characters)
- description: Description
- governance_area_id: ID of governance area
- parent_id: Parent indicator ID
- is_active: Active status
- is_profiling_only: Profiling-only flag
- is_auto_calculable: Auto-calculable Pass/Fail flag
- form_schema: Form schema (JSON)
- calculation_schema: Calculation schema (JSON)
- remark_schema: Remark schema (JSON)
- technical_notes_text: Technical notes

**Versioning Logic**:
- If any schema field (form_schema, calculation_schema, remark_schema) changes,
  the current version is archived to indicators_history and version is incremented
- Metadata changes (name, description, etc.) do not trigger versioning

**Returns**: Updated indicator

**Raises**:
- 404: Indicator not found
- 400: Circular parent reference detected
- 400: Invalid governance_area_id
 * @summary Update an indicator
 */
export const putIndicators$IndicatorId = (
    indicatorId: number,
    indicatorUpdate: IndicatorUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: indicatorUpdate
    },
      options);
    }
  


export const getPutIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext> => {

const mutationKey = ['putIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, {indicatorId: number;data: IndicatorUpdate}> = (props) => {
          const {indicatorId,data} = props ?? {};

          return  putIndicators$IndicatorId(indicatorId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIndicators$IndicatorId>>>
    export type PutIndicatorsIndicatorIdMutationBody = IndicatorUpdate
    export type PutIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Update an indicator
 */
export const usePutIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putIndicators$IndicatorId>>,
        TError,
        {indicatorId: number;data: IndicatorUpdate},
        TContext
      > => {

      const mutationOptions = getPutIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Deactivate an indicator (soft delete).

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to deactivate

**Returns**: Deactivated indicator (is_active=False)

**Raises**:
- 404: Indicator not found
- 400: Cannot deactivate indicator with active child indicators
 * @summary Deactivate an indicator
 */
export const deleteIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext> => {

const mutationKey = ['deleteIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, {indicatorId: number}> = (props) => {
          const {indicatorId} = props ?? {};

          return  deleteIndicators$IndicatorId(indicatorId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>>
    
    export type DeleteIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Deactivate an indicator
 */
export const useDeleteIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteIndicators$IndicatorId>>,
        TError,
        {indicatorId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get version history for an indicator.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: List of archived versions ordered by version DESC (newest first)

**Raises**:
- 404: Indicator not found
 * @summary Get indicator version history
 */
export const getIndicators$IndicatorIdHistory = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorHistoryResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/${indicatorId}/history`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorIdHistoryQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/${indicatorId}/history`] as const;
    }

    
export const getGetIndicatorsIndicatorIdHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorIdHistoryQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>> = ({ signal }) => getIndicators$IndicatorIdHistory(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorIdHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>>
export type GetIndicatorsIndicatorIdHistoryQueryError = HTTPValidationError


/**
 * @summary Get indicator version history
 */

export function useGetIndicatorsIndicatorIdHistory<TData = Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorIdHistoryQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



