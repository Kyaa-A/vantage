/**
 * // üöÄ Auto-generated by Orval (Axios + React Query)
 * // üîÑ Do not edit manually - regenerate with: pnpm generate-types
 * // üìÅ Organized by FastAPI tags for maximum maintainability
 * // üîê Uses custom Axios instance with auth & error handling
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetIndicatorsIndicatorsParams,
  HTTPValidationError,
  IndicatorCreate,
  IndicatorHistoryResponse,
  IndicatorResponse,
  IndicatorUpdate
} from '../../schemas';

import { mutator } from '../../../../../../apps/web/src/lib/api';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Create a new indicator with version 1.

**Permissions**: MLGOO_DILG only

**Request Body**:
- name: Indicator name (min 3 characters)
- description: Optional description
- governance_area_id: ID of governance area
- parent_id: Optional parent indicator ID (for hierarchical structure)
- is_active: Active status (default: True)
- is_profiling_only: Profiling-only flag (default: False)
- is_auto_calculable: Auto-calculable Pass/Fail flag (default: False)
- form_schema: Optional form schema (JSON)
- calculation_schema: Optional calculation schema (JSON)
- remark_schema: Optional remark schema (JSON)
- technical_notes_text: Optional technical notes

**Returns**: Created indicator with version 1
 * @summary Create a new indicator
 */
export const postIndicatorsIndicators = (
    indicatorCreate: IndicatorCreate,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: indicatorCreate, signal
    },
      options);
    }
  


export const getPostIndicatorsIndicatorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsIndicators>>, TError,{data: IndicatorCreate}, TContext> => {

const mutationKey = ['postIndicatorsIndicators'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIndicatorsIndicators>>, {data: IndicatorCreate}> = (props) => {
          const {data} = props ?? {};

          return  postIndicatorsIndicators(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIndicatorsIndicatorsMutationResult = NonNullable<Awaited<ReturnType<typeof postIndicatorsIndicators>>>
    export type PostIndicatorsIndicatorsMutationBody = IndicatorCreate
    export type PostIndicatorsIndicatorsMutationError = HTTPValidationError

    /**
 * @summary Create a new indicator
 */
export const usePostIndicatorsIndicators = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIndicatorsIndicators>>, TError,{data: IndicatorCreate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postIndicatorsIndicators>>,
        TError,
        {data: IndicatorCreate},
        TContext
      > => {

      const mutationOptions = getPostIndicatorsIndicatorsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * List indicators with optional filtering.

**Permissions**: All authenticated users

**Query Parameters**:
- governance_area_id: Filter by governance area (optional)
- is_active: Filter by active status (optional)
- skip: Pagination offset (default: 0)
- limit: Max records (default: 100, max: 1000)

**Returns**: List of indicators matching filters
 * @summary List all indicators
 */
export const getIndicatorsIndicators = (
    params?: GetIndicatorsIndicatorsParams,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorsQueryKey = (params?: GetIndicatorsIndicatorsParams,) => {
    return [`http://localhost:8000/api/v1/indicators/indicators/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIndicatorsIndicatorsQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsIndicators>>, TError = HTTPValidationError>(params?: GetIndicatorsIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsIndicators>>> = ({ signal }) => getIndicatorsIndicators(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsIndicators>>>
export type GetIndicatorsIndicatorsQueryError = HTTPValidationError


/**
 * @summary List all indicators
 */

export function useGetIndicatorsIndicators<TData = Awaited<ReturnType<typeof getIndicatorsIndicators>>, TError = HTTPValidationError>(
 params?: GetIndicatorsIndicatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get a specific indicator by ID.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: Indicator details including current version

**Raises**:
- 404: Indicator not found
 * @summary Get indicator by ID
 */
export const getIndicatorsIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/${indicatorId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorsIndicatorIdQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/indicators/${indicatorId}`] as const;
    }

    
export const getGetIndicatorsIndicatorsIndicatorIdQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorsIndicatorIdQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>> = ({ signal }) => getIndicatorsIndicators$IndicatorId(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorsIndicatorIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>>
export type GetIndicatorsIndicatorsIndicatorIdQueryError = HTTPValidationError


/**
 * @summary Get indicator by ID
 */

export function useGetIndicatorsIndicatorsIndicatorId<TData = Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorId>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorsIndicatorIdQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an indicator.

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to update

**Request Body**: All fields optional for partial updates
- name: Indicator name (min 3 characters)
- description: Description
- governance_area_id: ID of governance area
- parent_id: Parent indicator ID
- is_active: Active status
- is_profiling_only: Profiling-only flag
- is_auto_calculable: Auto-calculable Pass/Fail flag
- form_schema: Form schema (JSON)
- calculation_schema: Calculation schema (JSON)
- remark_schema: Remark schema (JSON)
- technical_notes_text: Technical notes

**Versioning Logic**:
- If any schema field (form_schema, calculation_schema, remark_schema) changes,
  the current version is archived to indicators_history and version is incremented
- Metadata changes (name, description, etc.) do not trigger versioning

**Returns**: Updated indicator

**Raises**:
- 404: Indicator not found
- 400: Circular parent reference detected
- 400: Invalid governance_area_id
 * @summary Update an indicator
 */
export const putIndicatorsIndicators$IndicatorId = (
    indicatorId: number,
    indicatorUpdate: IndicatorUpdate,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/${indicatorId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: indicatorUpdate
    },
      options);
    }
  


export const getPutIndicatorsIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext> => {

const mutationKey = ['putIndicatorsIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>, {indicatorId: number;data: IndicatorUpdate}> = (props) => {
          const {indicatorId,data} = props ?? {};

          return  putIndicatorsIndicators$IndicatorId(indicatorId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIndicatorsIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>>
    export type PutIndicatorsIndicatorsIndicatorIdMutationBody = IndicatorUpdate
    export type PutIndicatorsIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Update an indicator
 */
export const usePutIndicatorsIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number;data: IndicatorUpdate}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putIndicatorsIndicators$IndicatorId>>,
        TError,
        {indicatorId: number;data: IndicatorUpdate},
        TContext
      > => {

      const mutationOptions = getPutIndicatorsIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Deactivate an indicator (soft delete).

**Permissions**: MLGOO_DILG only

**Path Parameters**:
- indicator_id: ID of the indicator to deactivate

**Returns**: Deactivated indicator (is_active=False)

**Raises**:
- 404: Indicator not found
- 400: Cannot deactivate indicator with active child indicators
 * @summary Deactivate an indicator
 */
export const deleteIndicatorsIndicators$IndicatorId = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,) => {
      
      
      return mutator<IndicatorResponse>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/${indicatorId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIndicatorsIndicatorsIndicatorIdMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext> => {

const mutationKey = ['deleteIndicatorsIndicatorsIndicatorId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>, {indicatorId: number}> = (props) => {
          const {indicatorId} = props ?? {};

          return  deleteIndicatorsIndicators$IndicatorId(indicatorId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIndicatorsIndicatorsIndicatorIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>>
    
    export type DeleteIndicatorsIndicatorsIndicatorIdMutationError = HTTPValidationError

    /**
 * @summary Deactivate an indicator
 */
export const useDeleteIndicatorsIndicatorsIndicatorId = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>, TError,{indicatorId: number}, TContext>, request?: SecondParameter<typeof mutator>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteIndicatorsIndicators$IndicatorId>>,
        TError,
        {indicatorId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIndicatorsIndicatorsIndicatorIdMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * Get version history for an indicator.

**Permissions**: All authenticated users

**Path Parameters**:
- indicator_id: ID of the indicator

**Returns**: List of archived versions ordered by version DESC (newest first)

**Raises**:
- 404: Indicator not found
 * @summary Get indicator version history
 */
export const getIndicatorsIndicators$IndicatorIdHistory = (
    indicatorId: number,
 options?: SecondParameter<typeof mutator>,signal?: AbortSignal
) => {
      
      
      return mutator<IndicatorHistoryResponse[]>(
      {url: `http://localhost:8000/api/v1/indicators/indicators/${indicatorId}/history`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIndicatorsIndicatorsIndicatorIdHistoryQueryKey = (indicatorId: number,) => {
    return [`http://localhost:8000/api/v1/indicators/indicators/${indicatorId}/history`] as const;
    }

    
export const getGetIndicatorsIndicatorsIndicatorIdHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIndicatorsIndicatorsIndicatorIdHistoryQueryKey(indicatorId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>> = ({ signal }) => getIndicatorsIndicators$IndicatorIdHistory(indicatorId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(indicatorId),  staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type GetIndicatorsIndicatorsIndicatorIdHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>>
export type GetIndicatorsIndicatorsIndicatorIdHistoryQueryError = HTTPValidationError


/**
 * @summary Get indicator version history
 */

export function useGetIndicatorsIndicatorsIndicatorIdHistory<TData = Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>, TError = HTTPValidationError>(
 indicatorId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getIndicatorsIndicators$IndicatorIdHistory>>, TError, TData>, request?: SecondParameter<typeof mutator>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetIndicatorsIndicatorsIndicatorIdHistoryQueryOptions(indicatorId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



