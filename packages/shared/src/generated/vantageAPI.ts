/**
 * // ðŸš€ Auto-generated by Orval
 * // ðŸ”„ Do not edit manually - regenerate with: pnpm generate-types
 * 
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApiResponse,
  AuthToken,
  HTTPValidationError,
  HealthCheck,
  LoginRequest,
  Project,
  ProjectCreate,
  ProjectList,
  User
} from './vantageAPI.schemas';


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * @summary Root
 */
export type rootGetResponse200 = {
  data: ApiResponse
  status: 200
}
    
export type rootGetResponseComposite = rootGetResponse200;
    
export type rootGetResponse = rootGetResponseComposite & {
  headers: Headers;
}

export const getRootGetUrl = () => {


  

  return `http://localhost:8000/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  const res = await fetch(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: rootGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as rootGetResponse
}



export const getRootGetQueryKey = () => {
    return [`http://localhost:8000/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Health Check
 */
export type healthCheckHealthGetResponse200 = {
  data: HealthCheck
  status: 200
}
    
export type healthCheckHealthGetResponseComposite = healthCheckHealthGetResponse200;
    
export type healthCheckHealthGetResponse = healthCheckHealthGetResponseComposite & {
  headers: Headers;
}

export const getHealthCheckHealthGetUrl = () => {


  

  return `http://localhost:8000/health`
}

export const healthCheckHealthGet = async ( options?: RequestInit): Promise<healthCheckHealthGetResponse> => {
  
  const res = await fetch(getHealthCheckHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: healthCheckHealthGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as healthCheckHealthGetResponse
}



export const getHealthCheckHealthGetQueryKey = () => {
    return [`http://localhost:8000/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Hello
 */
export type helloApiHelloGetResponse200 = {
  data: ApiResponse
  status: 200
}
    
export type helloApiHelloGetResponseComposite = helloApiHelloGetResponse200;
    
export type helloApiHelloGetResponse = helloApiHelloGetResponseComposite & {
  headers: Headers;
}

export const getHelloApiHelloGetUrl = () => {


  

  return `http://localhost:8000/api/hello`
}

export const helloApiHelloGet = async ( options?: RequestInit): Promise<helloApiHelloGetResponse> => {
  
  const res = await fetch(getHelloApiHelloGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: helloApiHelloGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as helloApiHelloGetResponse
}



export const getHelloApiHelloGetQueryKey = () => {
    return [`http://localhost:8000/api/hello`] as const;
    }

    
export const getHelloApiHelloGetQueryOptions = <TData = Awaited<ReturnType<typeof helloApiHelloGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHelloApiHelloGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof helloApiHelloGet>>> = ({ signal }) => helloApiHelloGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HelloApiHelloGetQueryResult = NonNullable<Awaited<ReturnType<typeof helloApiHelloGet>>>
export type HelloApiHelloGetQueryError = unknown


export function useHelloApiHelloGet<TData = Awaited<ReturnType<typeof helloApiHelloGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof helloApiHelloGet>>,
          TError,
          Awaited<ReturnType<typeof helloApiHelloGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloApiHelloGet<TData = Awaited<ReturnType<typeof helloApiHelloGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof helloApiHelloGet>>,
          TError,
          Awaited<ReturnType<typeof helloApiHelloGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHelloApiHelloGet<TData = Awaited<ReturnType<typeof helloApiHelloGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Hello
 */

export function useHelloApiHelloGet<TData = Awaited<ReturnType<typeof helloApiHelloGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof helloApiHelloGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHelloApiHelloGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Current User
 */
export type getCurrentUserApiUsersMeGetResponse200 = {
  data: User
  status: 200
}
    
export type getCurrentUserApiUsersMeGetResponseComposite = getCurrentUserApiUsersMeGetResponse200;
    
export type getCurrentUserApiUsersMeGetResponse = getCurrentUserApiUsersMeGetResponseComposite & {
  headers: Headers;
}

export const getGetCurrentUserApiUsersMeGetUrl = () => {


  

  return `http://localhost:8000/api/users/me`
}

export const getCurrentUserApiUsersMeGet = async ( options?: RequestInit): Promise<getCurrentUserApiUsersMeGetResponse> => {
  
  const res = await fetch(getGetCurrentUserApiUsersMeGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getCurrentUserApiUsersMeGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getCurrentUserApiUsersMeGetResponse
}



export const getGetCurrentUserApiUsersMeGetQueryKey = () => {
    return [`http://localhost:8000/api/users/me`] as const;
    }

    
export const getGetCurrentUserApiUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserApiUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>> = ({ signal }) => getCurrentUserApiUsersMeGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserApiUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>>
export type GetCurrentUserApiUsersMeGetQueryError = unknown


export function useGetCurrentUserApiUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserApiUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUserApiUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User
 */

export function useGetCurrentUserApiUsersMeGet<TData = Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUserApiUsersMeGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserApiUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Login
 */
export type loginApiAuthLoginPostResponse200 = {
  data: AuthToken
  status: 200
}

export type loginApiAuthLoginPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type loginApiAuthLoginPostResponseComposite = loginApiAuthLoginPostResponse200 | loginApiAuthLoginPostResponse422;
    
export type loginApiAuthLoginPostResponse = loginApiAuthLoginPostResponseComposite & {
  headers: Headers;
}

export const getLoginApiAuthLoginPostUrl = () => {


  

  return `http://localhost:8000/api/auth/login`
}

export const loginApiAuthLoginPost = async (loginRequest: LoginRequest, options?: RequestInit): Promise<loginApiAuthLoginPostResponse> => {
  
  const res = await fetch(getLoginApiAuthLoginPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: loginApiAuthLoginPostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as loginApiAuthLoginPostResponse
}




export const getLoginApiAuthLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['loginApiAuthLoginPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginApiAuthLoginPost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiAuthLoginPost>>>
    export type LoginApiAuthLoginPostMutationBody = LoginRequest
    export type LoginApiAuthLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginApiAuthLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiAuthLoginPost>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginApiAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Logout
 */
export type logoutApiAuthLogoutPostResponse200 = {
  data: ApiResponse
  status: 200
}
    
export type logoutApiAuthLogoutPostResponseComposite = logoutApiAuthLogoutPostResponse200;
    
export type logoutApiAuthLogoutPostResponse = logoutApiAuthLogoutPostResponseComposite & {
  headers: Headers;
}

export const getLogoutApiAuthLogoutPostUrl = () => {


  

  return `http://localhost:8000/api/auth/logout`
}

export const logoutApiAuthLogoutPost = async ( options?: RequestInit): Promise<logoutApiAuthLogoutPostResponse> => {
  
  const res = await fetch(getLogoutApiAuthLogoutPostUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: logoutApiAuthLogoutPostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as logoutApiAuthLogoutPostResponse
}




export const getLogoutApiAuthLogoutPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>, TError,void, TContext> => {

const mutationKey = ['logoutApiAuthLogoutPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>, void> = () => {
          

          return  logoutApiAuthLogoutPost(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutApiAuthLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>>
    
    export type LogoutApiAuthLogoutPostMutationError = unknown

    /**
 * @summary Logout
 */
export const useLogoutApiAuthLogoutPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutApiAuthLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutApiAuthLogoutPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Projects
 */
export type getProjectsApiProjectsGetResponse200 = {
  data: ProjectList
  status: 200
}
    
export type getProjectsApiProjectsGetResponseComposite = getProjectsApiProjectsGetResponse200;
    
export type getProjectsApiProjectsGetResponse = getProjectsApiProjectsGetResponseComposite & {
  headers: Headers;
}

export const getGetProjectsApiProjectsGetUrl = () => {


  

  return `http://localhost:8000/api/projects`
}

export const getProjectsApiProjectsGet = async ( options?: RequestInit): Promise<getProjectsApiProjectsGetResponse> => {
  
  const res = await fetch(getGetProjectsApiProjectsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getProjectsApiProjectsGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getProjectsApiProjectsGetResponse
}



export const getGetProjectsApiProjectsGetQueryKey = () => {
    return [`http://localhost:8000/api/projects`] as const;
    }

    
export const getGetProjectsApiProjectsGetQueryOptions = <TData = Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectsApiProjectsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>> = ({ signal }) => getProjectsApiProjectsGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 300000, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProjectsApiProjectsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>>
export type GetProjectsApiProjectsGetQueryError = unknown


export function useGetProjectsApiProjectsGet<TData = Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectsApiProjectsGet>>,
          TError,
          Awaited<ReturnType<typeof getProjectsApiProjectsGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectsApiProjectsGet<TData = Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectsApiProjectsGet>>,
          TError,
          Awaited<ReturnType<typeof getProjectsApiProjectsGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProjectsApiProjectsGet<TData = Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Projects
 */

export function useGetProjectsApiProjectsGet<TData = Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProjectsApiProjectsGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProjectsApiProjectsGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Project
 */
export type createProjectApiProjectsPostResponse200 = {
  data: Project
  status: 200
}

export type createProjectApiProjectsPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type createProjectApiProjectsPostResponseComposite = createProjectApiProjectsPostResponse200 | createProjectApiProjectsPostResponse422;
    
export type createProjectApiProjectsPostResponse = createProjectApiProjectsPostResponseComposite & {
  headers: Headers;
}

export const getCreateProjectApiProjectsPostUrl = () => {


  

  return `http://localhost:8000/api/projects`
}

export const createProjectApiProjectsPost = async (projectCreate: ProjectCreate, options?: RequestInit): Promise<createProjectApiProjectsPostResponse> => {
  
  const res = await fetch(getCreateProjectApiProjectsPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      projectCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createProjectApiProjectsPostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createProjectApiProjectsPostResponse
}




export const getCreateProjectApiProjectsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProjectApiProjectsPost>>, TError,{data: ProjectCreate}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createProjectApiProjectsPost>>, TError,{data: ProjectCreate}, TContext> => {

const mutationKey = ['createProjectApiProjectsPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProjectApiProjectsPost>>, {data: ProjectCreate}> = (props) => {
          const {data} = props ?? {};

          return  createProjectApiProjectsPost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProjectApiProjectsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createProjectApiProjectsPost>>>
    export type CreateProjectApiProjectsPostMutationBody = ProjectCreate
    export type CreateProjectApiProjectsPostMutationError = HTTPValidationError

    /**
 * @summary Create Project
 */
export const useCreateProjectApiProjectsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProjectApiProjectsPost>>, TError,{data: ProjectCreate}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProjectApiProjectsPost>>,
        TError,
        {data: ProjectCreate},
        TContext
      > => {

      const mutationOptions = getCreateProjectApiProjectsPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
